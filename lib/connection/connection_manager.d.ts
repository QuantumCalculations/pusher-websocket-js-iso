import { default as EventsDispatcher } from '../events/dispatcher';
import { OneOffTimer as Timer } from '../utils/timers';
import ConnectionState from './state';
import Connection from "./connection";
import Strategy from "../strategies/strategy";
import StrategyRunner from "../strategies/strategy_runner";
export default class ConnectionManager extends EventsDispatcher {
    key: string;
    options: any;
    state: ConnectionState;
    connection: Connection;
    encrypted: boolean;
    timeline: any;
    socket_id: string;
    unavailableTimer: Timer;
    activityTimer: Timer;
    retryTimer: Timer;
    activityTimeout: number;
    strategy: Strategy;
    runner: StrategyRunner;
    errorCallbacks: any;
    handshakeCallbacks: any;
    connectionCallbacks: any;
    constructor(key: string, options: any);
    connect(): void;
    send(data: any): boolean;
    send_event(name: string, data: any, channel?: string): boolean;
    disconnect(): void;
    isEncrypted(): boolean;
    startConnecting(): void;
    abortConnecting(): void;
    disconnectInternally(): void;
    updateStrategy(): void;
    retryIn(delay: any): void;
    clearRetryTimer(): void;
    setUnavailableTimer(): void;
    clearUnavailableTimer(): void;
    sendActivityCheck(): void;
    resetActivityCheck(): void;
    stopActivityCheck(): void;
    buildConnectionCallbacks(): {
        message: (message: any) => void;
        ping: () => void;
        activity: () => void;
        error: (error: any) => void;
        closed: () => void;
    };
    buildHandshakeCallbacks(errorCallbacks: any): any;
    buildErrorCallbacks(): {
        ssl_only: (result: any) => void;
        refused: (result: any) => void;
        backoff: (result: any) => void;
        retry: (result: any) => void;
    };
    setConnection(connection: any): void;
    abandonConnection(): Connection;
    updateState(newState: ConnectionState, data?: any): void;
    shouldRetry(): boolean;
}
